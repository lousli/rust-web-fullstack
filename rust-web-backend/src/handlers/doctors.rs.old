use actix_web::{web, HttpResponse, Result};
use sqlx::SqlitePool;
use crate::models::{Doctor, DoctorImport, WeightConfig, CalculatedIndicators, ApiResponse, QueryParams};
use crate::algorithms::{ScoringAlgorithm, AlgorithmConfig};
use chrono::Utc;
use anyhow::anyhow;

/// 获取医生列表
pub async fn get_doctors(
    pool: web::Data<SqlitePool>,
    query: web::Query<QueryParams>,
) -> Result<HttpResponse> {
    let page = query.page.unwrap_or(1).max(1);
    let limit = query.limit.unwrap_or(20).min(100);
    let offset = (page - 1) * limit;

    // 构建查询条件
    let mut where_conditions = Vec::new();
    let mut query_params = Vec::new();

    if let Some(name) = &query.name {
        where_conditions.push("name LIKE ?");
        query_params.push(format!("%{}%", name));
    }

    if let Some(department) = &query.department {
        where_conditions.push("department = ?");
        query_params.push(department.clone());
    }

    if let Some(region) = &query.region {
        where_conditions.push("region = ?");
        query_params.push(region.clone());
    }

    if let Some(title) = &query.title {
        where_conditions.push("title = ?");
        query_params.push(title.clone());
    }

    let where_clause = if where_conditions.is_empty() {
        String::new()
    } else {
        format!("WHERE {}", where_conditions.join(" AND "))
    };    // 排序
    let order_by = match query.sort_by.as_deref() {
        Some("name") => "ORDER BY name",
        Some("created_at") => "ORDER BY created_at",
        Some("fans_count") => "ORDER BY fans_count DESC",
        Some("avg_play_count") => "ORDER BY avg_play_count DESC",
        _ => "ORDER BY created_at DESC",
    };

    let sql = format!(
        "SELECT * FROM doctors {} {} LIMIT ? OFFSET ?",
        where_clause, order_by
    );

    // 构建查询
    let mut query_builder = sqlx::query_as::<_, Doctor>(&sql);
    
    // 添加参数
    for param in &query_params {
        query_builder = query_builder.bind(param);
    }
    query_builder = query_builder.bind(limit).bind(offset);

    match query_builder.fetch_all(pool.get_ref()).await {
        Ok(doctors) => {
            // 获取总数
            let count_sql = format!("SELECT COUNT(*) FROM doctors {}", where_clause);
            let mut count_query = sqlx::query_scalar::<_, i64>(&count_sql);
            for param in &query_params {
                count_query = count_query.bind(param);
            }
            
            let total = count_query.fetch_one(pool.get_ref()).await.unwrap_or(0);

            let response = ApiResponse {
                code: 200,
                message: "获取医生列表成功".to_string(),
                data: Some(serde_json::json!({
                    "doctors": doctors,
                    "total": total,
                    "page": page,
                    "limit": limit
                })),
            };

            Ok(HttpResponse::Ok().json(response))
        }
        Err(e) => {
            eprintln!("查询医生列表失败: {}", e);
            let response = ApiResponse {
                code: 500,
                message: format!("查询失败: {}", e),
                data: None,
            };
            Ok(HttpResponse::InternalServerError().json(response))
        }
    }
}

/// 获取单个医生信息
pub async fn get_doctor(
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse> {
    let doctor_id = path.into_inner();

    match sqlx::query_as::<_, Doctor>("SELECT * FROM doctors WHERE id = ?")
        .bind(&doctor_id)
        .fetch_optional(pool.get_ref())
        .await
    {
        Ok(Some(doctor)) => {
            let response = ApiResponse {
                code: 200,
                message: "获取医生信息成功".to_string(),
                data: Some(doctor),
            };
            Ok(HttpResponse::Ok().json(response))
        }
        Ok(None) => {
            let response = ApiResponse {
                code: 404,
                message: "医生不存在".to_string(),
                data: None,
            };
            Ok(HttpResponse::NotFound().json(response))
        }
        Err(e) => {
            eprintln!("查询医生信息失败: {}", e);
            let response = ApiResponse {
                code: 500,
                message: format!("查询失败: {}", e),
                data: None,
            };
            Ok(HttpResponse::InternalServerError().json(response))
        }
    }
}

/// 添加医生
pub async fn add_doctor(
    pool: web::Data<SqlitePool>,
    doctor: web::Json<DoctorImport>,
) -> Result<HttpResponse> {
    let doctor_data = doctor.into_inner();
    
    // 生成医生ID
    let doctor_id = format!("DOC{:06}", 
        chrono::Utc::now().timestamp_millis() % 1000000
    );

    match sqlx::query(
        r#"
        INSERT INTO doctors (
            id, name, title, region, department, institution, institution_price, list_price,
            total_fans, total_likes, total_works, likes_7d, fans_15d, shares_30d, comments_30d,
            works_7d, performance_score, editing_score, visual_score
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        "#,
    )
    .bind(&doctor_id)
    .bind(&doctor_data.name)
    .bind(&doctor_data.title)
    .bind(&doctor_data.region)
    .bind(&doctor_data.department)
    .bind(&doctor_data.institution)
    .bind(doctor_data.institution_price)
    .bind(doctor_data.list_price)
    .bind(doctor_data.total_fans)
    .bind(doctor_data.total_likes)
    .bind(doctor_data.total_works)
    .bind(doctor_data.likes_7d)
    .bind(doctor_data.fans_15d)
    .bind(doctor_data.shares_30d)
    .bind(doctor_data.comments_30d)
    .bind(doctor_data.works_7d)
    .bind(doctor_data.performance_score)
    .bind(doctor_data.editing_score)
    .bind(doctor_data.visual_score)
    .execute(pool.get_ref())
    .await
    {
        Ok(_) => {
            let response = ApiResponse {
                code: 200,
                message: "添加医生成功".to_string(),
                data: Some(serde_json::json!({ "id": doctor_id })),
            };
            Ok(HttpResponse::Ok().json(response))
        }
        Err(e) => {
            eprintln!("添加医生失败: {}", e);
            let response = ApiResponse {
                code: 500,
                message: format!("添加失败: {}", e),
                data: None,
            };
            Ok(HttpResponse::InternalServerError().json(response))
        }
    }
}

/// 更新医生信息
pub async fn update_doctor(
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
    doctor: web::Json<DoctorImport>,
) -> Result<HttpResponse> {
    let doctor_id = path.into_inner();
    let doctor_data = doctor.into_inner();

    match sqlx::query(
        r#"
        UPDATE doctors SET 
            name = ?, title = ?, region = ?, department = ?, institution = ?, 
            institution_price = ?, list_price = ?, total_fans = ?, total_likes = ?,
            total_works = ?, likes_7d = ?, fans_15d = ?, shares_30d = ?, comments_30d = ?,
            works_7d = ?, performance_score = ?, editing_score = ?, visual_score = ?,
            updated_at = CURRENT_TIMESTAMP
        WHERE id = ?
        "#,
    )
    .bind(&doctor_data.name)
    .bind(&doctor_data.title)
    .bind(&doctor_data.region)
    .bind(&doctor_data.department)
    .bind(&doctor_data.institution)
    .bind(doctor_data.institution_price)
    .bind(doctor_data.list_price)
    .bind(doctor_data.total_fans)
    .bind(doctor_data.total_likes)
    .bind(doctor_data.total_works)
    .bind(doctor_data.likes_7d)
    .bind(doctor_data.fans_15d)
    .bind(doctor_data.shares_30d)
    .bind(doctor_data.comments_30d)
    .bind(doctor_data.works_7d)
    .bind(doctor_data.performance_score)
    .bind(doctor_data.editing_score)
    .bind(doctor_data.visual_score)
    .bind(&doctor_id)
    .execute(pool.get_ref())
    .await
    {
        Ok(result) => {
            if result.rows_affected() > 0 {
                let response = ApiResponse {
                    code: 200,
                    message: "更新医生信息成功".to_string(),
                    data: None,
                };
                Ok(HttpResponse::Ok().json(response))
            } else {
                let response = ApiResponse {
                    code: 404,
                    message: "医生不存在".to_string(),
                    data: None,
                };
                Ok(HttpResponse::NotFound().json(response))
            }
        }
        Err(e) => {
            eprintln!("更新医生信息失败: {}", e);
            let response = ApiResponse {
                code: 500,
                message: format!("更新失败: {}", e),
                data: None,
            };
            Ok(HttpResponse::InternalServerError().json(response))
        }
    }
}

/// 删除医生
pub async fn delete_doctor(
    pool: web::Data<SqlitePool>,
    path: web::Path<String>,
) -> Result<HttpResponse> {
    let doctor_id = path.into_inner();

    match sqlx::query("DELETE FROM doctors WHERE id = ?")
        .bind(&doctor_id)
        .execute(pool.get_ref())
        .await
    {
        Ok(result) => {
            if result.rows_affected() > 0 {
                let response = ApiResponse {
                    code: 200,
                    message: "删除医生成功".to_string(),
                    data: None,
                };
                Ok(HttpResponse::Ok().json(response))
            } else {
                let response = ApiResponse {
                    code: 404,
                    message: "医生不存在".to_string(),
                    data: None,
                };
                Ok(HttpResponse::NotFound().json(response))
            }
        }
        Err(e) => {
            eprintln!("删除医生失败: {}", e);
            let response = ApiResponse {
                code: 500,
                message: format!("删除失败: {}", e),
                data: None,
            };
            Ok(HttpResponse::InternalServerError().json(response))
        }
    }
}

/// 获取医生投放建议
pub async fn get_recommendations(
    pool: web::Data<SqlitePool>,
    query: web::Query<QueryParams>,
) -> Result<HttpResponse> {
    let limit = query.limit.unwrap_or(10).min(50);

    // 获取医生列表
    let doctors = match sqlx::query_as::<_, Doctor>("SELECT * FROM doctors")
        .fetch_all(pool.get_ref())
        .await
    {
        Ok(doctors) => doctors,
        Err(e) => {
            eprintln!("查询医生列表失败: {}", e);
            let response = ApiResponse {
                code: 500,
                message: format!("查询失败: {}", e),
                data: None,
            };
            return Ok(HttpResponse::InternalServerError().json(response));
        }
    };

    // 获取默认权重配置
    let weight_config = match sqlx::query_as::<_, WeightConfig>(
        "SELECT * FROM weight_configs WHERE is_default = 1 LIMIT 1"
    )
    .fetch_optional(pool.get_ref())
    .await
    {
        Ok(Some(config)) => config,
        Ok(None) => {
            let response = ApiResponse {
                code: 404,
                message: "未找到默认权重配置".to_string(),
                data: None,
            };
            return Ok(HttpResponse::NotFound().json(response));
        }
        Err(e) => {
            eprintln!("查询权重配置失败: {}", e);
            let response = ApiResponse {
                code: 500,
                message: format!("查询失败: {}", e),
                data: None,
            };
            return Ok(HttpResponse::InternalServerError().json(response));
        }
    };

    // 计算评分
    match ScoringAlgorithm::calculate_scores(&doctors, &weight_config) {
        Ok(scores) => {
            // 生成投放建议
            let recommendations = ScoringAlgorithm::get_investment_recommendations(
                &scores, &doctors, limit as usize
            );

            let response = ApiResponse {
                code: 200,
                message: "获取投放建议成功".to_string(),
                data: Some(serde_json::json!({
                    "recommendations": recommendations,
                    "total": recommendations.len()
                })),
            };
            Ok(HttpResponse::Ok().json(response))
        }
        Err(e) => {
            eprintln!("计算投放建议失败: {}", e);
            let response = ApiResponse {
                code: 500,
                message: format!("计算失败: {}", e),
                data: None,
            };
            Ok(HttpResponse::InternalServerError().json(response))
        }
    }
}
