# 交互逻辑设计

## 1. 页面路由管理

### 1.1 前端路由配置

```javascript
class Router {
    constructor() {
        this.routes = {
            '#dashboard': () => this.loadDashboard(),
            '#doctors': () => this.loadDoctors(),
            '#doctors/:id': (id) => this.loadDoctorDetail(id),
            '#weights': () => this.loadWeights(),
            '#reports': () => this.loadReports(),
            '#settings': () => this.loadSettings()
        };
        
        this.currentRoute = null;
        this.init();
    }
    
    init() {
        window.addEventListener('hashchange', () => this.handleRoute());
        window.addEventListener('load', () => this.handleRoute());
        this.handleRoute();
    }
    
    handleRoute() {
        const hash = window.location.hash || '#dashboard';
        const route = this.matchRoute(hash);
        
        if (route) {
            this.currentRoute = hash;
            route.handler(...route.params);
            this.updateNavigation(hash);
        }
    }
    
    navigate(path) {
        window.location.hash = path;
    }
    
    matchRoute(hash) {
        // 路由匹配逻辑
        for (const [pattern, handler] of Object.entries(this.routes)) {
            const match = this.matchPattern(pattern, hash);
            if (match) {
                return { handler, params: match.params };
            }
        }
        return null;
    }
}

const router = new Router();
```

### 1.2 页面加载管理

```javascript
class PageManager {
    constructor() {
        this.currentPage = null;
        this.pageCache = new Map();
        this.loadingState = false;
    }
    
    async loadPage(pageName, params = {}) {
        if (this.loadingState) return;
        
        this.setLoading(true);
        
        try {
            // 检查缓存
            const cacheKey = `${pageName}_${JSON.stringify(params)}`;
            if (this.pageCache.has(cacheKey)) {
                this.renderPage(this.pageCache.get(cacheKey));
                return;
            }
            
            // 加载页面数据
            const pageData = await this.fetchPageData(pageName, params);
            this.pageCache.set(cacheKey, pageData);
            this.renderPage(pageData);
            
        } catch (error) {
            this.showError('页面加载失败', error.message);
        } finally {
            this.setLoading(false);
        }
    }
    
    setLoading(loading) {
        this.loadingState = loading;
        const loadingElement = document.getElementById('loading-overlay');
        if (loadingElement) {
            loadingElement.style.display = loading ? 'flex' : 'none';
        }
    }
    
    renderPage(pageData) {
        const mainContent = document.getElementById('main-content');
        mainContent.innerHTML = pageData.html;
        
        // 执行页面特定的初始化
        if (pageData.init && typeof pageData.init === 'function') {
            pageData.init();
        }
    }
}
```

## 2. 数据管理和状态

### 2.1 状态管理

```javascript
class StateManager {
    constructor() {
        this.state = {
            doctors: {
                list: [],
                filters: {},
                pagination: { page: 1, pageSize: 20 },
                sorting: { field: 'comprehensive_index', order: 'desc' }
            },
            weights: {
                current: null,
                configs: [],
                isModified: false
            },
            ui: {
                activeTab: 'dashboard',
                sidebarCollapsed: false,
                theme: 'light'
            }
        };
        
        this.listeners = new Map();
    }
    
    // 订阅状态变化
    subscribe(key, callback) {
        if (!this.listeners.has(key)) {
            this.listeners.set(key, []);
        }
        this.listeners.get(key).push(callback);
    }
    
    // 更新状态
    setState(key, value) {
        const keys = key.split('.');
        let current = this.state;
        
        for (let i = 0; i < keys.length - 1; i++) {
            current = current[keys[i]];
        }
        
        current[keys[keys.length - 1]] = value;
        this.notifyListeners(key, value);
    }
    
    // 获取状态
    getState(key) {
        const keys = key.split('.');
        let current = this.state;
        
        for (const k of keys) {
            current = current[k];
            if (current === undefined) return undefined;
        }
        
        return current;
    }
    
    // 通知监听器
    notifyListeners(key, value) {
        const listeners = this.listeners.get(key) || [];
        listeners.forEach(callback => callback(value));
    }
}

const stateManager = new StateManager();
```

### 2.2 API请求管理

```javascript
class ApiManager {
    constructor() {
        this.baseUrl = '/api/v1';
        this.defaultHeaders = {
            'Content-Type': 'application/json'
        };
        this.requestCache = new Map();
        this.pendingRequests = new Map();
    }
    
    async request(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        const cacheKey = `${options.method || 'GET'}_${url}_${JSON.stringify(options.body)}`;
        
        // 检查是否有相同的请求正在进行
        if (this.pendingRequests.has(cacheKey)) {
            return this.pendingRequests.get(cacheKey);
        }
        
        // 检查缓存
        if (options.cache && this.requestCache.has(cacheKey)) {
            const cached = this.requestCache.get(cacheKey);
            if (Date.now() - cached.timestamp < options.cacheTime) {
                return cached.data;
            }
        }
        
        const requestOptions = {
            method: options.method || 'GET',
            headers: { ...this.defaultHeaders, ...options.headers },
            ...options
        };
        
        if (options.body && typeof options.body === 'object') {
            requestOptions.body = JSON.stringify(options.body);
        }
        
        // 创建请求Promise
        const requestPromise = fetch(url, requestOptions)
            .then(response => this.handleResponse(response))
            .then(data => {
                // 缓存结果
                if (options.cache) {
                    this.requestCache.set(cacheKey, {
                        data,
                        timestamp: Date.now()
                    });
                }
                return data;
            })
            .finally(() => {
                // 清除进行中的请求
                this.pendingRequests.delete(cacheKey);
            });
        
        this.pendingRequests.set(cacheKey, requestPromise);
        return requestPromise;
    }
    
    async handleResponse(response) {
        const data = await response.json();
        
        if (!response.ok) {
            throw new ApiError(data.error.message, data.error.code, response.status);
        }
        
        return data;
    }
    
    // 具体API方法
    async getDoctors(params = {}) {
        const queryString = new URLSearchParams(params).toString();
        return this.request(`/doctors?${queryString}`, { cache: true, cacheTime: 30000 });
    }
    
    async getDoctorDetail(doctorId) {
        return this.request(`/doctors/${doctorId}`, { cache: true, cacheTime: 60000 });
    }
    
    async updateWeights(configId, weights) {
        return this.request(`/weights/${configId}`, {
            method: 'PUT',
            body: weights
        });
    }
    
    async previewWeightChanges(weights) {
        return this.request('/calculate/preview', {
            method: 'POST',
            body: { weight_config: weights }
        });
    }
}

class ApiError extends Error {
    constructor(message, code, status) {
        super(message);
        this.code = code;
        this.status = status;
    }
}

const apiManager = new ApiManager();
```

## 3. 用户交互处理

### 3.1 表单验证

```javascript
class FormValidator {
    constructor() {
        this.rules = {
            required: (value) => value !== null && value !== undefined && value !== '',
            min: (value, min) => Number(value) >= min,
            max: (value, max) => Number(value) <= max,
            range: (value, min, max) => Number(value) >= min && Number(value) <= max,
            pattern: (value, pattern) => new RegExp(pattern).test(value)
        };
    }
    
    validate(formData, validationRules) {
        const errors = {};
        
        for (const [field, rules] of Object.entries(validationRules)) {
            const value = formData[field];
            const fieldErrors = [];
            
            for (const rule of rules) {
                const { type, params, message } = rule;
                
                if (!this.rules[type](value, ...params)) {
                    fieldErrors.push(message);
                }
            }
            
            if (fieldErrors.length > 0) {
                errors[field] = fieldErrors;
            }
        }
        
        return {
            isValid: Object.keys(errors).length === 0,
            errors
        };
    }
    
    // 实时验证
    setupRealTimeValidation(form, validationRules) {
        const inputs = form.querySelectorAll('input, select, textarea');
        
        inputs.forEach(input => {
            input.addEventListener('blur', () => {
                this.validateField(input, validationRules[input.name]);
            });
            
            input.addEventListener('input', () => {
                this.clearFieldError(input);
            });
        });
    }
    
    validateField(input, rules) {
        if (!rules) return;
        
        const validation = this.validate({ [input.name]: input.value }, { [input.name]: rules });
        
        if (!validation.isValid) {
            this.showFieldError(input, validation.errors[input.name][0]);
        } else {
            this.clearFieldError(input);
        }
    }
    
    showFieldError(input, message) {
        input.classList.add('error');
        
        let errorElement = input.parentNode.querySelector('.error-message');
        if (!errorElement) {
            errorElement = document.createElement('div');
            errorElement.className = 'error-message';
            input.parentNode.appendChild(errorElement);
        }
        
        errorElement.textContent = message;
    }
    
    clearFieldError(input) {
        input.classList.remove('error');
        
        const errorElement = input.parentNode.querySelector('.error-message');
        if (errorElement) {
            errorElement.remove();
        }
    }
}
```

### 3.2 权重调整交互

```javascript
class WeightController {
    constructor() {
        this.weights = {};
        this.totalWeight = 100;
        this.isAdjusting = false;
        this.init();
    }
    
    init() {
        this.setupWeightControls();
        this.setupPreviewMode();
    }
    
    setupWeightControls() {
        const weightInputs = document.querySelectorAll('.weight-control input');
        
        weightInputs.forEach(input => {
            const weightName = input.id.replace('-weight', '').replace('-', '_');
            
            // 滑动条和数字输入框同步
            if (input.type === 'range') {
                const numberInput = input.parentNode.querySelector('input[type="number"]');
                
                input.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    numberInput.value = value;
                    this.updateWeight(weightName, value);
                });
            } else if (input.type === 'number') {
                const rangeInput = input.parentNode.querySelector('input[type="range"]');
                
                input.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    rangeInput.value = value;
                    this.updateWeight(weightName, value);
                });
            }
        });
    }
    
    updateWeight(weightName, value) {
        this.weights[weightName] = value;
        this.validateWeights();
        this.updateTotalDisplay();
        
        // 防抖处理，避免频繁计算
        clearTimeout(this.updateTimer);
        this.updateTimer = setTimeout(() => {
            this.triggerPreviewUpdate();
        }, 500);
    }
    
    validateWeights() {
        const total = Object.values(this.weights).reduce((sum, weight) => sum + weight, 0);
        const isValid = Math.abs(total - 100) < 0.1;
        
        const validationElement = document.getElementById('weight-validation');
        const statusElement = validationElement.querySelector('.validation-status');
        
        if (isValid) {
            statusElement.className = 'validation-status valid';
            statusElement.innerHTML = '✓ 权重配置有效';
        } else {
            statusElement.className = 'validation-status invalid';
            statusElement.innerHTML = `⚠ 权重总和为 ${total.toFixed(1)}%，应为 100%`;
        }
        
        // 启用/禁用应用按钮
        const applyButton = document.getElementById('apply-weights');
        applyButton.disabled = !isValid;
        
        return isValid;
    }
    
    updateTotalDisplay() {
        const total = Object.values(this.weights).reduce((sum, weight) => sum + weight, 0);
        const totalElement = document.getElementById('total-weight-value');
        totalElement.textContent = `${total.toFixed(1)}%`;
        
        if (Math.abs(total - 100) > 0.1) {
            totalElement.classList.add('invalid');
        } else {
            totalElement.classList.remove('invalid');
        }
    }
    
    async triggerPreviewUpdate() {
        if (!this.validateWeights()) return;
        
        try {
            const preview = await apiManager.previewWeightChanges(this.weights);
            this.updatePreviewDisplay(preview);
        } catch (error) {
            console.error('预览计算失败:', error);
        }
    }
    
    updatePreviewDisplay(preview) {
        const previewPanel = document.getElementById('preview-panel');
        previewPanel.classList.remove('hidden');
        
        // 更新汇总信息
        document.getElementById('affected-count').textContent = preview.data.summary.total_affected;
        document.getElementById('avg-score-change').textContent = preview.data.summary.avg_score_change.toFixed(1);
        document.getElementById('max-rank-change').textContent = preview.data.summary.max_rank_change;
        
        // 更新详细表格
        const tbody = document.getElementById('preview-results');
        tbody.innerHTML = preview.data.doctors.map(doctor => `
            <tr>
                <td>${doctor.doctor_name}</td>
                <td>${doctor.current_score.toFixed(1)}</td>
                <td>${doctor.new_score.toFixed(1)}</td>
                <td class="${doctor.score_change >= 0 ? 'positive' : 'negative'}">
                    ${doctor.score_change >= 0 ? '+' : ''}${doctor.score_change.toFixed(1)}
                </td>
                <td>${doctor.current_rank}</td>
                <td>${doctor.new_rank}</td>
                <td class="${doctor.rank_change <= 0 ? 'positive' : 'negative'}">
                    ${doctor.rank_change <= 0 ? '+' : ''}${doctor.rank_change}
                </td>
            </tr>
        `).join('');
    }
    
    setupPreviewMode() {
        const previewButton = document.getElementById('preview-changes');
        previewButton.addEventListener('click', () => {
            this.triggerPreviewUpdate();
        });
        
        const applyButton = document.getElementById('apply-weights');
        applyButton.addEventListener('click', async () => {
            if (await this.applyWeights()) {
                this.showSuccessMessage('权重配置已应用成功');
                this.resetPreview();
            }
        });
    }
    
    async applyWeights() {
        try {
            await apiManager.updateWeights('current', this.weights);
            
            // 更新状态
            stateManager.setState('weights.current', this.weights);
            stateManager.setState('weights.isModified', false);
            
            return true;
        } catch (error) {
            this.showErrorMessage('权重应用失败: ' + error.message);
            return false;
        }
    }
}
```

### 3.3 数据筛选和排序

```javascript
class DoctorListController {
    constructor() {
        this.filters = {};
        this.sorting = { field: 'comprehensive_index', order: 'desc' };
        this.pagination = { page: 1, pageSize: 20 };
        
        this.init();
    }
    
    init() {
        this.setupFilters();
        this.setupSorting();
        this.setupPagination();
        this.setupSearch();
        
        // 初始加载
        this.loadDoctors();
    }
    
    setupFilters() {
        // 地区筛选
        const regionFilter = document.getElementById('filter-region');
        regionFilter.addEventListener('change', (e) => {
            this.updateFilter('region', e.target.value);
        });
        
        // 科室筛选
        const departmentFilter = document.getElementById('filter-department');
        departmentFilter.addEventListener('change', (e) => {
            this.updateFilter('department', e.target.value);
        });
        
        // 账号类型筛选
        const accountTypeFilter = document.getElementById('filter-account-type');
        accountTypeFilter.addEventListener('change', (e) => {
            this.updateFilter('account_type', e.target.value);
        });
        
        // 评分范围筛选
        const minScoreRange = document.getElementById('min-score');
        const maxScoreRange = document.getElementById('max-score');
        
        minScoreRange.addEventListener('input', (e) => {
            document.getElementById('min-score-value').textContent = e.target.value;
            this.updateFilter('min_score', parseFloat(e.target.value));
        });
        
        maxScoreRange.addEventListener('input', (e) => {
            document.getElementById('max-score-value').textContent = e.target.value;
            this.updateFilter('max_score', parseFloat(e.target.value));
        });
    }
    
    updateFilter(key, value) {
        if (value === '' || value === null || value === undefined) {
            delete this.filters[key];
        } else {
            this.filters[key] = value;
        }
        
        // 重置分页
        this.pagination.page = 1;
        
        // 重新加载数据
        this.loadDoctors();
    }
    
    setupSorting() {
        const sortBySelect = document.getElementById('sort-by');
        const sortOrderButton = document.getElementById('sort-order');
        
        sortBySelect.addEventListener('change', (e) => {
            this.sorting.field = e.target.value;
            this.loadDoctors();
        });
        
        sortOrderButton.addEventListener('click', () => {
            this.sorting.order = this.sorting.order === 'desc' ? 'asc' : 'desc';
            sortOrderButton.textContent = this.sorting.order === 'desc' ? '⬇️' : '⬆️';
            sortOrderButton.setAttribute('data-order', this.sorting.order);
            this.loadDoctors();
        });
    }
    
    setupSearch() {
        const searchInput = document.getElementById('search-input');
        const searchButton = document.getElementById('search-btn');
        
        let searchTimeout;
        
        searchInput.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                this.updateFilter('search', e.target.value);
            }, 300);
        });
        
        searchButton.addEventListener('click', () => {
            this.updateFilter('search', searchInput.value);
        });
        
        // 回车搜索
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.updateFilter('search', e.target.value);
            }
        });
    }
    
    async loadDoctors() {
        try {
            const params = {
                ...this.filters,
                ...this.pagination,
                sort_by: this.sorting.field,
                sort_order: this.sorting.order
            };
            
            const response = await apiManager.getDoctors(params);
            this.renderDoctorList(response.data);
            this.updatePagination(response.data.pagination);
            
        } catch (error) {
            this.showErrorMessage('加载医生列表失败: ' + error.message);
        }
    }
    
    renderDoctorList(data) {
        const viewMode = document.querySelector('#view-grid.active') ? 'grid' : 'list';
        
        if (viewMode === 'grid') {
            this.renderGridView(data.doctors);
        } else {
            this.renderListView(data.doctors);
        }
    }
    
    renderGridView(doctors) {
        const grid = document.getElementById('doctors-grid');
        grid.innerHTML = doctors.map(doctor => this.createDoctorCard(doctor)).join('');
        
        // 添加点击事件
        grid.querySelectorAll('.doctor-card').forEach(card => {
            card.addEventListener('click', () => {
                const doctorId = card.getAttribute('data-doctor-id');
                this.showDoctorDetail(doctorId);
            });
        });
    }
    
    createDoctorCard(doctor) {
        return `
            <div class="doctor-card" data-doctor-id="${doctor.id}">
                <div class="card-header">
                    <h3 class="doctor-name">${doctor.name}</h3>
                    <span class="account-type ${doctor.account_type}">${this.getAccountTypeLabel(doctor.account_type)}</span>
                </div>
                <div class="card-body">
                    <div class="doctor-info">
                        <p><strong>职称:</strong> ${doctor.title || '未知'}</p>
                        <p><strong>地区:</strong> ${doctor.region || '未知'}</p>
                        <p><strong>科室:</strong> ${doctor.department || '未知'}</p>
                        <p><strong>机构:</strong> ${doctor.agency_name || '未知'}</p>
                        <p><strong>报价:</strong> ¥${doctor.agency_price ? doctor.agency_price.toLocaleString() : '未知'}/条</p>
                        <p><strong>粉丝:</strong> ${doctor.total_followers.toLocaleString()}</p>
                    </div>
                    <div class="score-indicators">
                        <div class="score-item">
                            <span class="score-label">综合评分</span>
                            <span class="score-value primary">${doctor.comprehensive_index.toFixed(1)}</span>
                        </div>
                        <div class="score-item">
                            <span class="score-label">性价比</span>
                            <span class="score-value">${doctor.cost_effectiveness_index.toFixed(1)}</span>
                        </div>
                    </div>
                </div>
                <div class="card-footer">
                    <span class="rank">排名: #${doctor.rank || '-'}</span>
                    <button class="btn btn-sm btn-primary">查看详情</button>
                </div>
            </div>
        `;
    }
}
```
