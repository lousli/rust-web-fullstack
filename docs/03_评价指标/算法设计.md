# 评价指标算法设计

## 1. 算法概述

本系统采用多维度加权评价模型，通过以下几个核心指标来评估医生的投放价值：

1. **账号性质分类** - 基于粉丝量的影响力分级
2. **性价比指数** - 综合考虑报价、影响力和活跃度
3. **数据趋势指数** - 分析短期、中期、长期数据变化
4. **内容质量指数** - 基于人工评分的内容质量评估
5. **综合评价指数** - 多维度加权综合评分

## 2. 账号性质分类算法

### 2.1 分类标准

```rust
#[derive(Debug)]
pub enum AccountType {
    Head,    // 头部账号: 粉丝量 >= 500,000
    Middle,  // 腰部账号: 100,000 <= 粉丝量 < 500,000
    Tail,    // 尾部账号: 粉丝量 < 100,000
}

pub fn classify_account_type(followers: i32) -> AccountType {
    match followers {
        f if f >= 500_000 => AccountType::Head,
        f if f >= 100_000 => AccountType::Middle,
        _ => AccountType::Tail,
    }
}
```

### 2.2 账号性质评分

```rust
pub fn calculate_account_score(account_type: &AccountType, followers: i32) -> f32 {
    match account_type {
        AccountType::Head => {
            // 头部账号: 基础分80分，超过50万粉丝每10万加2分，最高100分
            let base_score = 80.0;
            let bonus = ((followers - 500_000) / 100_000) as f32 * 2.0;
            (base_score + bonus).min(100.0)
        },
        AccountType::Middle => {
            // 腰部账号: 基础分40分，粉丝量线性映射到40-80分
            let ratio = (followers - 100_000) as f32 / 400_000.0;
            40.0 + ratio * 40.0
        },
        AccountType::Tail => {
            // 尾部账号: 粉丝量线性映射到0-40分
            let ratio = followers as f32 / 100_000.0;
            ratio * 40.0
        }
    }
}
```

## 3. 性价比指数算法

### 3.1 算法思路

性价比指数综合考虑：
- 机构报价（成本因素）
- 账号影响力（粉丝量、总获赞量）
- 近期活跃度（近期点赞、评论、分享）

```rust
pub fn calculate_cost_effectiveness(
    price: f64,
    followers: i32,
    total_likes: i32,
    likes_7d: i32,
    comments_7d: i32,
    shares_7d: i32,
) -> f32 {
    // 影响力分数 (0-100)
    let influence_score = calculate_influence_score(followers, total_likes);
    
    // 活跃度分数 (0-100)
    let activity_score = calculate_activity_score(likes_7d, comments_7d, shares_7d);
    
    // 综合价值分数
    let value_score = influence_score * 0.6 + activity_score * 0.4;
    
    // 性价比 = 价值分数 / 标准化价格
    let normalized_price = normalize_price(price);
    
    (value_score / normalized_price * 100.0).min(100.0)
}

fn calculate_influence_score(followers: i32, total_likes: i32) -> f32 {
    // 粉丝量分数 (占60%)
    let follower_score = (followers as f32).log10() * 20.0;
    
    // 获赞量分数 (占40%)
    let likes_score = (total_likes as f32).log10() * 15.0;
    
    ((follower_score * 0.6 + likes_score * 0.4).min(100.0)).max(0.0)
}

fn calculate_activity_score(likes_7d: i32, comments_7d: i32, shares_7d: i32) -> f32 {
    // 近7天互动总量
    let total_engagement = likes_7d + comments_7d * 5 + shares_7d * 10;
    
    // 对数标准化，避免极值影响
    ((total_engagement as f32).log10() * 25.0).min(100.0).max(0.0)
}

fn normalize_price(price: f64) -> f32 {
    // 价格标准化：以5000元为基准价格
    let base_price = 5000.0;
    (price / base_price) as f32
}
```

## 4. 数据趋势指数算法

### 4.1 趋势分析

分析7天、15天、30天的数据变化趋势，评估医生的成长性和稳定性。

```rust
pub fn calculate_data_trend_index(
    likes_7d: i32, likes_15d: i32, likes_30d: i32,
    followers_7d: i32, followers_15d: i32, followers_30d: i32,
    works_7d: i32, works_15d: i32, works_30d: i32,
) -> f32 {
    // 计算各周期的增长率
    let likes_growth = calculate_growth_trend(likes_7d, likes_15d, likes_30d);
    let followers_growth = calculate_growth_trend(followers_7d, followers_15d, followers_30d);
    let works_efficiency = calculate_content_efficiency(works_7d, works_15d, works_30d, likes_7d, likes_15d, likes_30d);
    
    // 加权综合
    let trend_score = likes_growth * 0.4 + followers_growth * 0.4 + works_efficiency * 0.2;
    
    trend_score.min(100.0).max(0.0)
}

fn calculate_growth_trend(val_7d: i32, val_15d: i32, val_30d: i32) -> f32 {
    // 计算日均增长
    let daily_7d = val_7d as f32 / 7.0;
    let daily_15d = val_15d as f32 / 15.0;
    let daily_30d = val_30d as f32 / 30.0;
    
    // 趋势评分：近期表现越好分数越高
    let short_term_weight = 0.5;
    let medium_term_weight = 0.3;
    let long_term_weight = 0.2;
    
    let weighted_daily = daily_7d * short_term_weight + 
                        daily_15d * medium_term_weight + 
                        daily_30d * long_term_weight;
    
    // 标准化到0-100分
    (weighted_daily.log10() * 30.0 + 50.0).min(100.0).max(0.0)
}

fn calculate_content_efficiency(
    works_7d: i32, works_15d: i32, works_30d: i32,
    likes_7d: i32, likes_15d: i32, likes_30d: i32
) -> f32 {
    if works_7d == 0 || works_15d == 0 || works_30d == 0 {
        return 0.0;
    }
    
    // 计算单条内容的平均获赞数
    let efficiency_7d = likes_7d as f32 / works_7d as f32;
    let efficiency_15d = likes_15d as f32 / works_15d as f32;
    let efficiency_30d = likes_30d as f32 / works_30d as f32;
    
    // 内容效率趋势
    let avg_efficiency = (efficiency_7d + efficiency_15d + efficiency_30d) / 3.0;
    
    (avg_efficiency.log10() * 25.0 + 50.0).min(100.0).max(0.0)
}
```

## 5. 内容质量指数算法

### 5.1 人工评分整合

```rust
pub fn calculate_content_quality_index(
    performance_score: Option<f32>,
    affinity_score: Option<f32>,
    editing_score: Option<f32>,
    video_quality_score: Option<f32>,
) -> f32 {
    // 收集有效评分
    let mut scores = Vec::new();
    let mut weights = Vec::new();
    
    if let Some(score) = performance_score {
        scores.push(score);
        weights.push(0.3); // 表现力权重30%
    }
    
    if let Some(score) = affinity_score {
        scores.push(score);
        weights.push(0.25); // 亲和力权重25%
    }
    
    if let Some(score) = editing_score {
        scores.push(score);
        weights.push(0.25); // 剪辑水平权重25%
    }
    
    if let Some(score) = video_quality_score {
        scores.push(score);
        weights.push(0.2); // 画面质量权重20%
    }
    
    if scores.is_empty() {
        return 0.0;
    }
    
    // 标准化权重
    let total_weight: f32 = weights.iter().sum();
    let normalized_weights: Vec<f32> = weights.iter().map(|w| w / total_weight).collect();
    
    // 加权平均，转换为0-100分制
    let weighted_sum: f32 = scores.iter()
        .zip(normalized_weights.iter())
        .map(|(score, weight)| score * weight)
        .sum();
    
    weighted_sum * 10.0 // 10分制转100分制
}
```

## 6. 综合评价指数算法

### 6.1 多维度加权计算

```rust
pub fn calculate_comprehensive_index(
    account_score: f32,
    cost_effectiveness: f32,
    data_trend: f32,
    content_quality: f32,
    weight_config: &WeightConfig,
) -> f32 {
    let total_weight = weight_config.account_type_weight +
                      weight_config.cost_effectiveness_weight +
                      weight_config.data_trend_weight +
                      weight_config.content_quality_weight();
    
    if total_weight == 0.0 {
        return 0.0;
    }
    
    let weighted_sum = account_score * weight_config.account_type_weight +
                       cost_effectiveness * weight_config.cost_effectiveness_weight +
                       data_trend * weight_config.data_trend_weight +
                       content_quality * weight_config.content_quality_weight();
    
    weighted_sum / total_weight
}

impl WeightConfig {
    fn content_quality_weight(&self) -> f32 {
        self.performance_weight + 
        self.affinity_weight + 
        self.editing_weight + 
        self.video_quality_weight
    }
}
```

## 7. 算法参数配置

### 7.1 可调参数

```rust
pub struct AlgorithmConfig {
    // 账号分类阈值
    pub head_account_threshold: i32,
    pub middle_account_threshold: i32,
    
    // 性价比计算参数
    pub base_price: f64,
    pub influence_weight: f32,
    pub activity_weight: f32,
    
    // 趋势分析权重
    pub trend_7d_weight: f32,
    pub trend_15d_weight: f32,
    pub trend_30d_weight: f32,
    
    // 内容质量权重
    pub performance_weight: f32,
    pub affinity_weight: f32,
    pub editing_weight: f32,
    pub video_quality_weight: f32,
}

impl Default for AlgorithmConfig {
    fn default() -> Self {
        Self {
            head_account_threshold: 500_000,
            middle_account_threshold: 100_000,
            base_price: 5000.0,
            influence_weight: 0.6,
            activity_weight: 0.4,
            trend_7d_weight: 0.5,
            trend_15d_weight: 0.3,
            trend_30d_weight: 0.2,
            performance_weight: 0.3,
            affinity_weight: 0.25,
            editing_weight: 0.25,
            video_quality_weight: 0.2,
        }
    }
}
```

## 8. 算法验证和优化

### 8.1 算法测试

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_account_classification() {
        assert_eq!(classify_account_type(600_000), AccountType::Head);
        assert_eq!(classify_account_type(300_000), AccountType::Middle);
        assert_eq!(classify_account_type(50_000), AccountType::Tail);
    }

    #[test]
    fn test_cost_effectiveness_calculation() {
        let score = calculate_cost_effectiveness(
            5000.0, 100_000, 50_000, 1000, 100, 50
        );
        assert!(score > 0.0 && score <= 100.0);
    }

    #[test]
    fn test_comprehensive_index_bounds() {
        let config = WeightConfig::default();
        let index = calculate_comprehensive_index(
            85.0, 75.0, 80.0, 90.0, &config
        );
        assert!(index >= 0.0 && index <= 100.0);
    }
}
```

### 8.2 性能优化

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

pub struct AlgorithmCache {
    config: Arc<RwLock<AlgorithmConfig>>,
    // 缓存计算结果
    calculated_scores: Arc<RwLock<HashMap<String, CachedScore>>>,
}

#[derive(Clone)]
struct CachedScore {
    score: f32,
    calculated_at: DateTime<Utc>,
    config_version: u64,
}

impl AlgorithmCache {
    pub async fn get_or_calculate(&self, doctor_id: &str, data: &DoctorData) -> f32 {
        // 检查缓存
        if let Some(cached) = self.get_cached_score(doctor_id).await {
            if self.is_cache_valid(&cached).await {
                return cached.score;
            }
        }
        
        // 重新计算
        let score = self.calculate_fresh_score(data).await;
        self.cache_score(doctor_id, score).await;
        score
    }
}
```
